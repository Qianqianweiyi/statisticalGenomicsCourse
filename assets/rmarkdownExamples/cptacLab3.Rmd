---
title: "Intro to MSqRob"
author: "Lieven Clement"
output:
  html_notebook: default
---

## Background	
This case-study is a subset of the data of the 6th study of the Clinical Proteomic Technology Assessment for Cancer (CPTAC). 
In this experiment, the authors spiked the Sigma Universal Protein Standard mixture 1 (UPS1) containing 48 different human proteins in a protein background of 60 ng/$\mu$L Saccharomyces cerevisiae strain BY4741.
Two different spike-in concentrations were used: 6A (0.25 fmol UPS1 proteins/$\mu$L) and 6B (0.74 fmol UPS1 proteins/$\mu$L) [5]. 
We limited ourselves to the data of LTQ-Orbitrap W at site 56. 
The data were searched with MaxQuant version 1.5.2.8, and detailed search settings were described in Goeminne et al. (2016) [1].
Three replicates are available for each concentration.

## 1. Data

We first import the peptides.txt file. This is the file that contains your peptide-level intensities. For a MaxQuant search [6], this peptides.txt file can be found by default in the "path_to_raw_files/combined/txt/" folder from the MaxQuant output, with "path_to_raw_files" the folder where raw files were saved. In this tutorial, we will use a MaxQuant peptides file from MaxQuant that can be found on the pdaData repository.
We will use the MSnbase package to import the data.

We generate the object peptideFile with the path to the peptides.txt file. 
In this file we assume that we work in the directory where the peptides.txt and proteingroups.txt file are located. 
With the grepEcols function we find the columns that are containing the expression data of the peptides in the peptides.txt file. 

```{r}
library(MSqRob)
library(MSnbase)
library(tidyverse)
peptidesFile <- "https://raw.githubusercontent.com/statOmics/statisticalGenomicsCourse/data/quantification/cptacAvsB_lab3/peptides.txt"
proteinGroupsFile <-"https://raw.githubusercontent.com/statOmics/statisticalGenomicsCourse/data/quantification/cptacAvsB_lab3/proteinGroups.txt"
ecols<-grepEcols(peptidesFile, "Intensity ", split = "\t")
```

Next we import the peptide intensities 

```{r}
pepData<-readMSnSet2(peptidesFile,ecol=ecols,fnames="Sequence",sep="\t")
pepData
```

The pepData object is an MSnSet, a container for the data, features information and experimental annotation.
They can be accessed using the accessor functions 'exprs' (matrix of intensities, features in rows, samples in columns), 'fData' (properties for each feature, peptide or protein, on the rows) and 'pData' (properties for the samples on the columns).

We will make use from data wrangling functionalities from the tidyverse package.
The %>% operator allows us to pipe the output of one function to the next function. 

```{r}
head(exprs(pepData))
pepData %>% exprs %>% head 
pepData %>% sampleNames
```

The sample names are rather long and contain information on the spike-in concentration and the repeat.
We will remove "Intensity.6" from the string 

```{r}
sampleNames(pepData) <- pepData %>% sampleNames %>% str_replace(., pattern="Intensity.6", replacement="")
```

Next we will add information on the proteins to the feature data.
The feature data of the object pepData contains information for each peptide in the experiment.
This info on the proteins can be found in the proteingroups.txt file of maxquant. 
The peptides.txt file contains many data on each feature (peptide). 
We will drop all the columns and only retain specified columns using the transmute function. 
We will keep the protein, sequence, reverse and contaminant columns indicating the protein, peptide sequence, if the peptide is a decoy and if it is a contaminant, respectively. We will transform the reverse from a vector of strings containing "" if the peptide is a forward match and "+" if it is a decoy to a boolean. The contaminant column is generated by looking in the protein names for the substring "CON__". 
Some ups sequences are also included in the crap dataset and are flagged as contaminants. We will not indicating them as such. 


```{r}
fd <- fData(pepData) %>%
  transmute(protein = Proteins %>% as.character,
            sequence = Sequence,
            reverse = grepl("\\+", Reverse),
            contaminant = grepl("CON__", protein) & !grepl("ups", protein))
```

We now add the info from the protein groups file to the feature data and only retain the protein info and the only.site info. 
We add this to the fd data that we already have. 
The data is added according to the matching variable protein. 
The protein variable is recasted into a factor, which is required in the downstream analysis.
We will later replace the fData from the pepData object by the new dataframe we constructed. 
It is therefore nessecary that the data frame contains the same rownames.
They were lost during data wrangling. 

```{r}
fd <- read.table(proteinGroupsFile, sep = "\t", header = TRUE, quote = "", comment.char = "", stringsAsFactors = FALSE) %>%
  transmute(protein = Protein.IDs, only.site = grepl("\\+", Only.identified.by.site)) %>%
  right_join(fd) 
rownames(fd) <- featureNames(pepData)
fd$protein<-as.factor(fd$protein)
```


Next we create the data on the experimental layout. 
We can do this based on the samplenames. 
Again the pheno data is required to have the same rownames as the samples (columns of pepData). 

```{r}
pd <- data.frame(condition = pepData %>% sampleNames %>% substr(1,1) %>% as.factor)
rownames(pd)<- sampleNames(pepData)
```

We replace the fData and the pData with the objects we just created 

```{r}
fData(pepData)<-fd
pData(pepData)<-pd
```

## 2. Preprocessing

We will log transform, normalize, filter and summarize the data.

### 2.1. Log transform the data
```{r}
pepData <- log(pepData, base = 2)
#Change -Inf values in the peptide intensities to NA
exprs <- exprs(pepData)
exprs[is.infinite(exprs)] <- NA
exprs(pepData) <- exprs
```

### 2.2. Remove contaminants, reverse sequences and only identified by site
```{r}
pepData <- pepData[pepData %>% fData %>% filter(!(reverse|contaminant|only.site)) %>% select(sequence) %>% unlist]
```

### 2.3. Drop peptides that were only identified in one sample 
```{r}
pepData<-pepData[pepData %>% exprs %>% is.na %>% `!` %>% rowSums >=2]
```


### 2.4. Quantile normalize the data
```{r}
pepData <- normalise(pepData, "quantiles")
```


```{r}
library(limma)
plotMDS(exprs(pepData))
```

We notice that the leading differences (log FC) in the peptide data seems to occur according to technical variability. 

### 2.5. Summarization to protein level
```{r}
protData<-combineFeatures(pepData,groupBy=fData(pepData)$protein,fun="robust")
```

```{r}
plotMDS(exprs(protData))
```

We notice that the leading differences (log FC) in the protein data is still according to technical variation. On the second dimension, however, we also observe a clear separation according to the spike-in condition. Hence, the summarization that accounts for peptide specific effects makes the effects due to the spike-in condition more prominent!


## 3. Data Analysis

### 3.1. Estimation
MSqRob is currently working with a format where we have one dataframe for each protein. 
This will be changed in the next release. 
Therefore we first have to reorganise the data. 

Next the models are fitted. 
This is done using the fit.model function. 
We only have to model the data using the factor condition. 
This is specified in the fixed argument. 
The argument shrinkage is used to specify if ridge regression has to be adopted. 
For the sake of speed we do not do this in the tutorial. 
The shrinkage has to be specified for each variable in the fixed effects. 
We also have to indicate this for the intercept (which we never shrink).
So we specify it at c(0,0) to indicate that the intercept (first 0) and the parameters for the factor condition (second 0) are not penalized.


```{r}
protMSqRob <- MSnSet2protdata(protData, "protein")
models <- fit.model(protdata=protMSqRob, response="quant_value", fixed="condition",shrinkage.fixed=c(0,0))
```

### 3.2. Inference
Many biologists have problems with the reference coding. 
In MSqRob we have opted to formulate contrasts using all levels of a factor. 
Internally, the contrasts are than recasted according to the factor level that is the reference class. 

```{r}
L <- makeContrast("conditionB - conditionA",  levels=c("conditionA","conditionB"))
tests <- test.contrast_adjust(models, L)
nSig <- sum(tests$signif,na.rm=TRUE)
head(tests,nSig)
```

###3.3. Plots

Volcano-plot

```{r}
plot(-log10(pval)~estimate,tests,col=signif+1)
```

Detail plot for significant proteins.

```{r}
for (protName in rownames(tests)[1:nSig])
{
plotDat<-pepData[(pepData %>% fData %>% select(protein))==protName] %>% exprs
plotDataStack<-data.frame(quant_value=c(plotDat),sequence=rep(rownames(plotDat),rep=ncol(plotDat)),sample=rep(colnames(plotDat),each=nrow(plotDat)),condition=rep(pData(pepData)$condition,each=nrow(plotDat)))
plot1 <- ggplot(plotDataStack, aes(x=sample, y=quant_value,fill=condition))
print(plot1 +geom_boxplot(outlier.shape=NA) + geom_point(position=position_jitter(width=.1),aes(shape=sequence)) + scale_shape_manual(values=1:nrow(plotDat)) +labs(title = protName, x="sample", y="Peptide intensity (log2)"))
}
```

Sensitivity FDP plots

Because we know the ground truth for the cptac study, i.e. we know that only the spike-in proteins (UPS) are differentially expressed, we can calculate 

- the sensitivity or true positive rate (TPR), the proportion of actual positives that are correctly identified, in the protein list that we return
$$TPR=\frac{TP}{\text{#actual positives}}$$
- false discovery proportion (FPD): fraction of false positives in the protein list that we return:
$$FPD=\frac{FP}{FP+TP}$$

Instead of only calculating that for the protein list at a particular FDR, we can do this for all possible FDR cutoffs so that we get an overview of the quality of the ranking of the proteins in the protein list. 

```{r}
tests<-tests %>% 
mutate(protName=rownames(.),
ups=grepl("ups",protName),
FDP=cumsum(!ups)/(1:length(ups)),
TPR=cumsum(ups)/sum(ups))

rownames(tests)<-tests$protName

ggplot(tests,aes(x=FDP,y=TPR)) + geom_path() +geom_vline(xintercept=0.05,lty=2) + geom_point(data=tests[sum(tests$signif,na.rm=TRUE),],aes(x=FDP,y=TPR),cex=2)
```

We observe that there is a good FDR control: the FDP at the 5% FDR level is indeed close to 0.05.